# 广告投放新需求技术方案

## 一、需求概述

### 1.1 Excel表格导入功能
- **位置**：广告投放页面"商品信息"标题旁边
- **功能**：导入Excel表格，识别并提取特定字段
- **字段识别**：
  - `商品ID` - 对应广告投放页面的"商品ID"字段
  - `商品spu` - 对应广告投放页面的"商品SPU"字段
  - `商品主图` - 对应广告投放页面的"商品图片链接"字段
  - `商品属性*` - 筛选字段，只收集值为"M"的行数据

### 1.2 图片拼接外链同步功能
- **数据流**：图片拼接页面 → 生成拼图 → 上传外链 → 复制外链 → 同步到广告投放页面
- **位置对应关系**：
  - 位置1：主图（left槽位）
  - 位置2：右上图（topRight槽位）
  - 位置3：右下图（bottomRight槽位）
- **同步规则**：
  - 首次同步：覆盖
  - 后续同步：追加

### 1.3 数据对应关系管理
- **核心关系**：外链 ↔ 3个图片链接（有序） ↔ 商品ID/商品SPU
- **数据结构**：一个外链对应3个商品ID和3个商品SPU
- **存储方式**：商品ID和商品SPU按英文逗号","分隔，三个为一组

### 1.4 对齐功能
- **功能**：当数据顺序不对应时，自动对齐
- **对齐规则**：商品ID和商品SPU按3个一组，与外链对齐
- **表格生成**：最终生成ABO和URL表格时，商品ID和商品SPU按3个一组用逗号分隔

---

## 二、技术实现方案

### 2.1 Excel表格导入功能

#### 2.1.1 前端实现

**依赖库**：需要安装Excel解析库
```bash
npm install xlsx
```

**文件位置**：`frontend/src/views/AdCampaign.vue`

**实现步骤**：

1. **添加导入按钮**
   - 在"商品信息"标题旁边添加"导入表格"按钮
   - 使用隐藏的`<input type="file">`实现文件选择

2. **文件选择处理**
   ```javascript
   // 处理Excel文件选择
   const handleExcelImport = (event) => {
     const file = event.target.files[0]
     if (!file) return
     
     // 验证文件类型
     const validTypes = [
       'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
       'application/vnd.ms-excel' // .xls
     ]
     if (!validTypes.includes(file.type)) {
       ElMessage.error('请选择Excel文件（.xlsx或.xls格式）')
       return
     }
     
     // 读取Excel文件
     parseExcelFile(file)
   }
   ```

3. **Excel解析逻辑**
   ```javascript
   import * as XLSX from 'xlsx'
   
   const parseExcelFile = (file) => {
     const reader = new FileReader()
     reader.onload = (e) => {
       try {
         const data = new Uint8Array(e.target.result)
         const workbook = XLSX.read(data, { type: 'array' })
         
         // 读取第一个工作表
         const firstSheetName = workbook.SheetNames[0]
         const worksheet = workbook.Sheets[firstSheetName]
         
         // 转换为JSON数组
         const jsonData = XLSX.utils.sheet_to_json(worksheet)
         
         // 处理数据
         processExcelData(jsonData)
       } catch (error) {
         ElMessage.error('Excel文件解析失败：' + error.message)
       }
     }
     reader.readAsArrayBuffer(file)
   }
   ```

4. **数据筛选和处理**
   ```javascript
   const processExcelData = (jsonData) => {
     // 识别表头（支持多种可能的表头名称）
     const headers = {
       productId: ['商品ID', '商品id', 'productId', 'Product ID'],
       productSpu: ['商品spu', '商品SPU', 'SPU', 'spu'],
       productImage: ['商品主图', '商品图片', 'productImage', 'Product Image'],
       productAttribute: ['商品属性*', '商品属性', 'Product Attribute', '属性']
     }
     
     // 查找表头索引
     const findHeaderIndex = (row, possibleHeaders) => {
       for (let i = 0; i < row.length; i++) {
         const cellValue = String(row[i] || '').trim()
         if (possibleHeaders.includes(cellValue)) {
           return i
         }
       }
       return -1
     }
     
     // 筛选"M"属性的数据
     const filteredData = jsonData.filter(row => {
       const attrValue = String(row[headers.productAttribute] || '').trim().toUpperCase()
       return attrValue === 'M'
     })
     
     // 提取三个字段的数据
     const productIds = []
     const productSpus = []
     const productImages = []
     
     filteredData.forEach(row => {
       const id = String(row[headers.productId] || '').trim()
       const spu = String(row[headers.productSpu] || '').trim()
       const image = String(row[headers.productImage] || '').trim()
       
       if (id && spu && image) {
         productIds.push(id)
         productSpus.push(spu)
         productImages.push(image)
       }
     })
     
     // 填充到表单
     formData['商品ID'] = productIds.join('\n')
     formData['商品SPU'] = productSpus.join('\n')
     formData['商品图片链接'] = productImages.join('\n')
     
     ElMessage.success(`成功导入 ${filteredData.length} 条数据`)
   }
   ```

#### 2.1.2 表头识别策略

由于Excel表格可能存在多种表头名称，需要实现灵活的识别机制：

1. **精确匹配**：优先匹配完全相同的表头名称
2. **模糊匹配**：支持忽略大小写、空格等差异
3. **容错处理**：如果找不到某个表头，给出明确的错误提示

---

### 2.2 图片拼接外链同步功能

#### 2.2.1 数据结构设计

需要在图片拼接页面记录每个位置的图片链接信息：

```javascript
// 在 imageStitch.js store 中添加
const stitchRecords = ref([]) // 拼图记录数组

// 每条记录的结构
{
  id: 'stitch-xxx', // 唯一ID
  externalLink: 'https://imgfi.com/xxx.jpg', // 外链
  imageLinks: [
    { position: 1, link: 'https://...', materialId: 'xxx' }, // 位置1（主图）
    { position: 2, link: 'https://...', materialId: 'yyy' }, // 位置2（右上）
    { position: 3, link: 'https://...', materialId: 'zzz' }  // 位置3（右下）
  ],
  createdAt: 1234567890 // 创建时间戳
}
```

#### 2.2.2 修改图片拼接页面

**文件位置**：`frontend/src/views/ImageStitch.vue`

**修改点**：

1. **记录槽位图片链接**
   ```javascript
   // 在handleDrop方法中，记录图片链接
   const handleDrop = (event, slot) => {
     // ... 原有逻辑 ...
     
     // 记录图片链接（从material中获取originalUrl）
     const material = store.getMaterialById(materialId)
     if (material && material.originalUrl) {
       // 记录当前槽位的图片链接
       recordSlotImageLink(slot, material.originalUrl, materialId)
     }
   }
   
   // 记录槽位图片链接的方法
   const recordSlotImageLink = (slot, imageLink, materialId) => {
     // 将槽位名称映射到位置编号
     const positionMap = {
       'left': 1,
       'topRight': 2,
       'bottomRight': 3
     }
     
     const position = positionMap[slot]
     if (!position) return
     
     // 记录到当前拼图记录中
     if (!currentStitchRecord.value) {
       currentStitchRecord.value = {
         id: `stitch-${Date.now()}`,
         imageLinks: []
       }
     }
     
     // 更新对应位置的图片链接
     const existingIndex = currentStitchRecord.value.imageLinks.findIndex(
       item => item.position === position
     )
     
     const linkData = {
       position,
       link: imageLink,
       materialId
     }
     
     if (existingIndex >= 0) {
       currentStitchRecord.value.imageLinks[existingIndex] = linkData
     } else {
       currentStitchRecord.value.imageLinks.push(linkData)
     }
   }
   ```

2. **上传外链后记录**
   ```javascript
   // 修改handleUploadToImgfi方法
   const handleUploadToImgfi = async () => {
     // ... 原有上传逻辑 ...
     
     if (response.data && response.data.success && response.data.url) {
       imgfiUrl.value = response.data.url
       
       // 记录外链到当前拼图记录
       if (currentStitchRecord.value) {
         currentStitchRecord.value.externalLink = response.data.url
         currentStitchRecord.value.createdAt = Date.now()
         
         // 保存到store
         store.addStitchRecord(currentStitchRecord.value)
         
         // 同步到广告投放页面
         syncExternalLinkToAdCampaign(response.data.url, currentStitchRecord.value.imageLinks)
         
         // 重置当前记录（为下次拼图做准备）
         currentStitchRecord.value = null
       }
     }
   }
   ```

3. **复制外链时同步**
   ```javascript
   // 修改handleCopyImgfiUrl方法
   const handleCopyImgfiUrl = async () => {
     // ... 原有复制逻辑 ...
     
     // 如果还没有同步，则同步
     if (currentStitchRecord.value && currentStitchRecord.value.externalLink) {
       syncExternalLinkToAdCampaign(
         imgfiUrl.value,
         currentStitchRecord.value.imageLinks
       )
     }
   }
   ```

#### 2.2.3 同步到广告投放页面

**实现方式**：使用全局状态管理或事件总线

**方案A：使用Pinia Store（推荐）**

在`adCampaign.js` store中添加：

```javascript
// 外链同步相关的状态
const externalLinks = ref([]) // 存储所有同步过来的外链
const imageLinkMapping = ref({}) // 存储图片链接与外链的映射关系

// 添加外链的方法
const addExternalLink = (externalLink, imageLinks) => {
  // 检查是否是首次（覆盖模式）
  const isFirst = externalLinks.value.length === 0
  
  if (isFirst) {
    // 首次：覆盖
    externalLinks.value = [externalLink]
    imageLinkMapping.value[externalLink] = imageLinks
  } else {
    // 后续：追加
    externalLinks.value.push(externalLink)
    imageLinkMapping.value[externalLink] = imageLinks
  }
  
  // 更新商品图片链接字段
  updateProductImageLinksField()
}

// 更新商品图片链接字段
const updateProductImageLinksField = () => {
  // 将外链数组转换为多行文本
  const linksText = externalLinks.value.join('\n')
  formData['商品图片链接'] = linksText
}
```

**方案B：使用事件总线**

在图片拼接页面发送事件，在广告投放页面监听：

```javascript
// 在ImageStitch.vue中
import { useEventBus } from '@/composables/useEventBus'

const eventBus = useEventBus()

const syncExternalLinkToAdCampaign = (externalLink, imageLinks) => {
  eventBus.emit('external-link-synced', {
    externalLink,
    imageLinks
  })
}

// 在AdCampaign.vue中
onMounted(() => {
  eventBus.on('external-link-synced', (data) => {
    // 处理外链同步
    handleExternalLinkSync(data)
  })
})
```

---

### 2.3 数据对应关系管理

#### 2.3.1 数据结构设计

需要在广告投放页面维护以下数据结构：

```javascript
// 在 adCampaign.js store 中
const productDataMapping = ref({
  // 外链 -> 图片链接数组（有序）
  externalLinks: [],
  
  // 图片链接 -> 商品ID/商品SPU的映射
  imageToProduct: {},
  
  // 商品ID/商品SPU数组（按顺序）
  productIds: [],
  productSpus: []
})
```

#### 2.3.2 建立对应关系

当导入Excel表格时，需要建立图片链接与商品ID/商品SPU的对应关系：

```javascript
// 处理Excel导入时
const processExcelData = (jsonData) => {
  // ... 提取数据 ...
  
  // 建立映射关系
  productDataMapping.value.productIds = productIds
  productDataMapping.value.productSpus = productSpus
  
  // 建立图片链接到商品的映射
  productImages.forEach((imageLink, index) => {
    productDataMapping.value.imageToProduct[imageLink] = {
      productId: productIds[index],
      productSpu: productSpus[index]
    }
  })
}
```

当外链同步过来时，需要建立外链与图片链接的对应关系：

```javascript
const addExternalLink = (externalLink, imageLinks) => {
  // 添加外链
  externalLinks.value.push(externalLink)
  
  // 记录外链对应的图片链接（有序）
  productDataMapping.value.externalLinks.push({
    externalLink,
    imageLinks: imageLinks.map(item => item.link)
  })
}
```

#### 2.3.3 外链到商品的对应关系

通过图片链接作为中间桥梁，建立外链与商品的对应关系：

```javascript
// 根据外链查找对应的商品ID和商品SPU
const getProductsByExternalLink = (externalLink) => {
  // 找到外链对应的图片链接数组
  const linkRecord = productDataMapping.value.externalLinks.find(
    item => item.externalLink === externalLink
  )
  
  if (!linkRecord) return null
  
  // 通过图片链接查找对应的商品ID和商品SPU
  const products = linkRecord.imageLinks.map(imageLink => {
    return productDataMapping.value.imageToProduct[imageLink]
  }).filter(Boolean) // 过滤掉找不到的商品信息
  
  return products
}
```

---

### 2.4 对齐功能

#### 2.4.1 对齐按钮

在广告投放页面的"商品信息"区域添加对齐按钮：

```html
<div class="form-group">
  <label for="商品图片链接">商品图片链接/商品视频链接 <span class="required">*</span></label>
  <div style="display: flex; gap: 10px; align-items: center;">
    <textarea id="商品图片链接" v-model="formData['商品图片链接']" required></textarea>
    <el-button type="primary" @click="handleAlignData">对齐数据</el-button>
  </div>
</div>
```

#### 2.4.2 对齐逻辑

```javascript
const handleAlignData = () => {
  // 1. 获取当前的外链列表
  const externalLinks = productDataMapping.value.externalLinks.map(item => item.externalLink)
  
  // 2. 获取商品ID和商品SPU数组
  const productIds = productDataMapping.value.productIds
  const productSpus = productDataMapping.value.productSpus
  
  // 3. 按照外链顺序，重新组织商品ID和商品SPU
  // 每个外链对应3个商品ID和3个商品SPU
  const alignedProductIds = []
  const alignedProductSpus = []
  
  externalLinks.forEach((externalLink) => {
    const products = getProductsByExternalLink(externalLink)
    
    if (products && products.length === 3) {
      // 每个外链对应3个商品，将这3个商品的ID和SPU添加到对齐后的数组
      products.forEach(product => {
        alignedProductIds.push(product.productId)
        alignedProductSpus.push(product.productSpu)
      })
    }
  })
  
  // 4. 更新表单数据
  formData['商品ID'] = alignedProductIds.join('\n')
  formData['商品SPU'] = alignedProductSpus.join('\n')
  
  ElMessage.success('数据对齐完成')
}
```

#### 2.4.3 表格生成时的分组处理

在生成ABO和URL表格时，需要将商品ID和商品SPU按3个一组处理：

```javascript
// 在generateAllTables方法中
const generateAllTables = async () => {
  // ... 原有逻辑 ...
  
  // 处理商品ID和商品SPU（按3个一组）
  const processedProductIds = formData['商品ID'] ? processMultiLineInput(formData['商品ID']) : ''
  const processedProductSpus = formData['商品SPU'] ? processMultiLineInput(formData['商品SPU']) : ''
  const processedProductImages = formData['商品图片链接'] ? processMultiLineInput(formData['商品图片链接']) : ''
  
  const productIds = processedProductIds ? processedProductIds.split('\n').filter(id => id.trim()) : []
  const productSpus = processedProductSpus ? processedProductSpus.split('\n').filter(spu => spu.trim()) : []
  const productImages = processedProductImages ? processedProductImages.split('\n').filter(img => img.trim()) : []
  
  // 按3个一组分组商品ID和商品SPU
  const groupedProductIds = []
  const groupedProductSpus = []
  
  for (let i = 0; i < productIds.length; i += 3) {
    const groupIds = productIds.slice(i, i + 3)
    const groupSpus = productSpus.slice(i, i + 3)
    
    // 用英文逗号连接
    groupedProductIds.push(groupIds.join(','))
    groupedProductSpus.push(groupSpus.join(','))
  }
  
  // 外链数量（每个外链对应一组商品ID和商品SPU）
  const externalLinkCount = productImages.length
  
  // 确保分组后的数量与外链数量一致
  if (groupedProductIds.length !== externalLinkCount) {
    ElMessage.warning(`商品ID分组数量（${groupedProductIds.length}）与外链数量（${externalLinkCount}）不一致`)
  }
  
  // 生成表格数据时，使用分组后的数据
  // 表格行数 = 外链数量（而不是商品ID的数量）
  // 每行的商品ID和商品SPU字段 = 3个一组，用逗号分隔
}
```

---

## 三、实现步骤

### 阶段一：Excel表格导入功能
1. 安装xlsx依赖库
2. 在AdCampaign.vue中添加导入按钮
3. 实现Excel文件读取和解析
4. 实现数据筛选（"商品属性*"为"M"）
5. 实现数据提取和填充到表单

### 阶段二：图片拼接外链同步功能
1. 修改imageStitch.js store，添加拼图记录数据结构
2. 修改ImageStitch.vue，记录每个槽位的图片链接
3. 实现外链上传后的记录功能
4. 实现同步到广告投放页面的功能（使用Store或事件总线）

### 阶段三：数据对应关系管理
1. 在adCampaign.js store中添加数据映射结构
2. 实现Excel导入时的映射建立
3. 实现外链同步时的映射建立
4. 实现通过图片链接查找商品信息的逻辑

### 阶段四：对齐功能
1. 添加对齐按钮
2. 实现对齐全逻辑
3. 修改表格生成逻辑，支持3个一组的分组

### 阶段五：测试和优化
1. 功能测试
2. 边界情况处理
3. 错误处理优化
4. 用户体验优化

---

## 四、注意事项

1. **Excel文件格式兼容性**：需要支持.xlsx和.xls格式
2. **表头识别**：需要处理表头名称的多种可能情况
3. **数据验证**：导入的数据需要验证完整性
4. **错误处理**：各个环节都需要完善的错误处理
5. **用户体验**：操作过程需要明确的提示和反馈
6. **数据一致性**：确保外链、图片链接、商品ID/SPU的对应关系正确
7. **性能优化**：大量数据处理时需要考虑性能

---

## 五、测试用例

### 5.1 Excel导入测试
- 测试正常Excel文件导入
- 测试"商品属性*"筛选功能
- 测试表头识别（不同表头名称）
- 测试数据缺失情况
- 测试大量数据导入

### 5.2 外链同步测试
- 测试首次同步（覆盖模式）
- 测试后续同步（追加模式）
- 测试图片链接记录
- 测试多个外链同步

### 5.3 对齐功能测试
- 测试正常对齐
- 测试数据不完整情况
- 测试数量不匹配情况

### 5.4 表格生成测试
- 测试3个一组的分组
- 测试分组后的表格格式
- 测试数量验证

