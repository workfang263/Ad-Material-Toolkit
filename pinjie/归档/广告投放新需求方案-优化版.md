# 广告投放新需求技术方案（优化版）

## 一、需求概述

### 1.1 Excel表格导入功能
- **位置**：广告投放页面"商品信息"标题旁边
- **功能**：导入Excel表格，识别并提取特定字段
- **字段识别**：
  - `商品ID` - 对应广告投放页面的"商品ID"字段
  - `商品spu` - 对应广告投放页面的"商品SPU"字段
  - `商品主图` - 对应广告投放页面的"商品图片链接"字段
  - `商品属性*` - 筛选字段，只收集值为"M"的行数据

### 1.2 图片拼接外链同步功能
- **数据流**：图片拼接页面 → 生成拼图 → 上传外链 → 复制外链 → 同步到广告投放页面
- **位置对应关系**：
  - 位置1：主图（left槽位）
  - 位置2：右上图（topRight槽位）
  - 位置3：右下图（bottomRight槽位）
- **同步规则**：
  - 首次同步：覆盖
  - 后续同步：追加（带去重检查）

### 1.3 数据对应关系管理
- **核心关系**：外链 ↔ 3个图片链接（有序） ↔ 商品ID/商品SPU
- **数据结构**：一个外链对应3个商品ID和3个商品SPU
- **存储方式**：商品ID和商品SPU按英文逗号","分隔，三个为一组
- **URL归一化**：所有图片链接匹配时使用归一化处理（忽略大小写、参数、协议差异等）

### 1.4 对齐功能
- **功能**：当数据顺序不对应时，自动对齐
- **对齐规则**：商品ID和商品SPU按3个一组，与外链对齐
- **表格生成**：最终生成ABO和URL表格时，商品ID和商品SPU按3个一组用逗号分隔
- **视觉反馈**：显示对齐状态、已对齐组数、未匹配图片数量等

---

## 二、核心优化点

### 2.1 URL归一化处理 ✅ 采纳

**问题**：Excel里的链接可能是 http，素材库里可能是 https，或者末尾带了参数。如果字符串不完全一致，对齐功能就会失效。

**解决方案**：在所有图片链接匹配的地方统一使用URL归一化函数。

```javascript
/**
 * URL归一化函数
 * 统一处理URL格式，用于匹配时忽略差异
 * @param {string} url - 原始URL
 * @returns {string} - 归一化后的URL
 */
const normalizeUrl = (url) => {
  if (!url || typeof url !== 'string') return ''
  
  try {
    // 去除首尾空格
    const trimmedUrl = url.trim()
    if (!trimmedUrl) return ''
    
    // 使用URL对象解析（自动处理协议、域名、路径、参数等）
    const u = new URL(trimmedUrl)
    
    // 统一转小写，只保留协议+域名+路径（去掉参数和锚点）
    return (u.origin + u.pathname).toLowerCase()
  } catch (e) {
    // 如果URL解析失败（可能是相对路径或其他格式），降级处理
    // 去除常见的查询参数和锚点
    const cleaned = trimmedUrl
      .split('?')[0]  // 去掉查询参数
      .split('#')[0]  // 去掉锚点
      .toLowerCase()
      .trim()
    
    return cleaned
  }
}
```

**使用场景**：
1. Excel导入时，归一化"商品主图"字段的URL
2. 图片拼接页面记录图片链接时，归一化URL
3. 建立映射关系时，使用归一化的URL作为key
4. 对齐功能匹配时，使用归一化的URL进行比较

---

### 2.2 状态持久化 ✅ 采纳

**问题**：用户导入Excel或同步外链后，如果页面刷新，所有数据会丢失。

**解决方案**：使用 `pinia-plugin-persistedstate` 插件实现状态持久化。

```bash
npm install pinia-plugin-persistedstate
```

**配置示例**：

```javascript
// main.js 或 stores/index.js
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)
```

**在 adCampaign.js store 中使用**：

```javascript
export const useAdCampaignStore = defineStore('adCampaign', () => {
  // ... 其他状态 ...
  
  // 数据映射关系（持久化）
  const productDataMapping = ref({
    externalLinks: [],
    imageToProduct: {},
    productIds: [],
    productSpus: []
  })
  
  return {
    productDataMapping,
    // ... 其他返回值 ...
  }
}, {
  persist: {
    key: 'ad-campaign-data', // localStorage 的 key
    storage: window.localStorage,
    paths: ['productDataMapping'] // 只持久化这个字段
  }
})
```

**优势**：
- 页面刷新后数据不会丢失
- 如果使用相同的localStorage key，跨标签页也可以共享状态
- 配置简单，无需手动处理localStorage

---

### 2.3 Excel导入的智能映射与预览 ✅ 采纳

**问题**：如果自动识别表头失败，用户会不知所措。

**解决方案**：增加手动映射功能和导入预览。

#### 2.3.1 自动识别失败时的处理

```javascript
const processExcelData = (jsonData) => {
  // 1. 尝试自动识别表头
  const headers = autoDetectHeaders(jsonData[0] || {})
  
  // 2. 检查是否所有必需的表头都找到了
  const requiredHeaders = ['productId', 'productSpu', 'productImage', 'productAttribute']
  const missingHeaders = requiredHeaders.filter(key => !headers[key])
  
  if (missingHeaders.length > 0) {
    // 3. 如果缺少表头，弹出对话框让用户手动选择
    showManualMappingDialog(jsonData[0], missingHeaders).then(manualHeaders => {
      // 合并自动识别和手动选择的结果
      const finalHeaders = { ...headers, ...manualHeaders }
      // 继续处理数据
      processExcelDataWithHeaders(jsonData, finalHeaders)
    })
    return
  }
  
  // 4. 如果自动识别成功，直接处理数据（但先显示预览）
  processExcelDataWithHeaders(jsonData, headers)
}
```

#### 2.3.2 手动映射对话框

```javascript
const showManualMappingDialog = (firstRow, missingHeaders) => {
  return new Promise((resolve) => {
    // 使用 Element Plus 的 Dialog 组件
    ElMessageBox({
      title: '表头映射',
      message: h('div', [
        h('p', '自动识别失败，请手动选择对应的列：'),
        // 为每个缺失的表头创建下拉选择框
        ...missingHeaders.map(header => {
          return h('div', { style: 'margin: 10px 0;' }, [
            h('label', getHeaderLabel(header)),
            h('select', {
              onChange: (e) => {
                manualHeaders[header] = e.target.value
              }
            }, [
              h('option', { value: '' }, '请选择'),
              ...Object.keys(firstRow).map(colName => {
                return h('option', { value: colName }, colName)
              })
            ])
          ])
        })
      ]),
      showCancelButton: true,
      confirmButtonText: '确定',
      cancelButtonText: '取消'
    }).then(() => {
      resolve(manualHeaders)
    }).catch(() => {
      // 用户取消
      resolve(null)
    })
  })
}
```

#### 2.3.3 导入预览功能

```javascript
const processExcelDataWithHeaders = (jsonData, headers) => {
  // 1. 筛选"M"属性的数据
  const filteredData = jsonData.filter(row => {
    const attrValue = String(row[headers.productAttribute] || '').trim().toUpperCase()
    return attrValue === 'M'
  })
  
  // 2. 提取数据（但先不填充到表单）
  const extractedData = {
    productIds: [],
    productSpus: [],
    productImages: []
  }
  
  filteredData.forEach(row => {
    const id = String(row[headers.productId] || '').trim()
    const spu = String(row[headers.productSpu] || '').trim()
    const image = normalizeUrl(String(row[headers.productImage] || '').trim())
    
    if (id && spu && image) {
      extractedData.productIds.push(id)
      extractedData.productSpus.push(spu)
      extractedData.productImages.push(image)
    }
  })
  
  // 3. 显示预览对话框
  showImportPreviewDialog(extractedData).then(confirmed => {
    if (confirmed) {
      // 用户确认后，才填充到表单
      formData['商品ID'] = extractedData.productIds.join('\n')
      formData['商品SPU'] = extractedData.productSpus.join('\n')
      formData['商品图片链接'] = extractedData.productImages.join('\n')
      
      // 建立映射关系
      buildImageToProductMapping(extractedData)
      
      ElMessage.success(`成功导入 ${extractedData.productIds.length} 条数据`)
    }
  })
}
```

#### 2.3.4 预览对话框

```javascript
const showImportPreviewDialog = (extractedData) => {
  return ElMessageBox.confirm(
    `检测到 ${extractedData.productIds.length} 条"商品属性*"为"M"的数据\n` +
    `商品ID: ${extractedData.productIds.length} 个\n` +
    `商品SPU: ${extractedData.productSpus.length} 个\n` +
    `商品主图: ${extractedData.productImages.length} 个\n\n` +
    `是否确认导入？`,
    '导入预览',
    {
      confirmButtonText: '确认导入',
      cancelButtonText: '取消',
      type: 'info'
    }
  ).then(() => true).catch(() => false)
}
```

---

### 2.4 对齐功能的视觉反馈 ✅ 采纳

**问题**：对齐功能是黑盒，用户不知道对齐是否成功。

**解决方案**：增加对齐状态检测和可视化反馈。

#### 2.4.1 对齐状态检测

```javascript
// 检测对齐状态
const checkAlignmentStatus = () => {
  const externalLinks = productDataMapping.value.externalLinks || []
  const imageToProduct = productDataMapping.value.imageToProduct || {}
  
  let alignedCount = 0      // 已对齐的组数
  let unmatchedImages = []  // 未匹配的图片
  let incompleteGroups = [] // 不完整的组（找到的图片少于3张）
  
  externalLinks.forEach((linkRecord, index) => {
    const { externalLink, imageLinks } = linkRecord
    const matchedProducts = []
    
    // 检查每个图片链接是否能找到对应的商品信息
    imageLinks.forEach(imageLink => {
      const normalizedLink = normalizeUrl(imageLink)
      const product = imageToProduct[normalizedLink]
      
      if (product) {
        matchedProducts.push({
          imageLink,
          product
        })
      } else {
        unmatchedImages.push(imageLink)
      }
    })
    
    // 如果找到了3个商品信息，说明这一组已对齐
    if (matchedProducts.length === 3) {
      alignedCount++
    } else if (matchedProducts.length > 0) {
      // 部分匹配（不完整）
      incompleteGroups.push({
        externalLink,
        matched: matchedProducts.length,
        total: 3
      })
    }
  })
  
  return {
    totalGroups: externalLinks.length,
    alignedCount,
    unmatchedImagesCount: unmatchedImages.length,
    incompleteGroups,
    unmatchedImages
  }
}
```

#### 2.4.2 可视化反馈UI

```vue
<template>
  <div class="form-group">
    <label for="商品图片链接">商品图片链接/商品视频链接 <span class="required">*</span></label>
    <textarea id="商品图片链接" v-model="formData['商品图片链接']" required></textarea>
    
    <!-- 对齐状态显示 -->
    <div class="alignment-status" v-if="alignmentStatus">
      <div class="status-item" :class="{ 'status-ok': alignmentStatus.alignedCount === alignmentStatus.totalGroups }">
        <span class="status-label">已对齐:</span>
        <span class="status-value">{{ alignmentStatus.alignedCount }} / {{ alignmentStatus.totalGroups }} 组</span>
      </div>
      
      <div class="status-item" v-if="alignmentStatus.unmatchedImagesCount > 0" style="color: #f56c6c;">
        <span class="status-label">未匹配图片:</span>
        <span class="status-value">{{ alignmentStatus.unmatchedImagesCount }} 个</span>
      </div>
      
      <div class="status-item" v-if="alignmentStatus.incompleteGroups.length > 0" style="color: #e6a23c;">
        <span class="status-label">不完整组:</span>
        <span class="status-value">{{ alignmentStatus.incompleteGroups.length }} 组</span>
        <el-tooltip>
          <template #content>
            <div v-for="(group, index) in alignmentStatus.incompleteGroups" :key="index">
              外链 {{ index + 1 }}: 仅匹配 {{ group.matched }}/3 张图片
            </div>
          </template>
          <el-icon><Warning /></el-icon>
        </el-tooltip>
      </div>
    </div>
    
    <div style="display: flex; gap: 10px; margin-top: 10px;">
      <el-button type="primary" @click="handleAlignData">对齐数据</el-button>
      <el-button type="info" @click="checkAlignmentStatus">检测对齐状态</el-button>
    </div>
  </div>
</template>

<script setup>
const alignmentStatus = ref(null)

// 对齐状态检测（在数据变化时自动检测）
watch([
  () => formData['商品图片链接'],
  () => productDataMapping.value
], () => {
  alignmentStatus.value = checkAlignmentStatus()
}, { immediate: true, deep: true })
</script>

<style scoped>
.alignment-status {
  display: flex;
  gap: 20px;
  margin-top: 8px;
  padding: 8px;
  background-color: #f5f7fa;
  border-radius: 4px;
  font-size: 12px;
}

.status-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.status-label {
  font-weight: 500;
}

.status-value {
  font-weight: 600;
}

.status-ok {
  color: #67c23a;
}
</style>
```

---

### 2.5 外链同步去重 ✅ 采纳

**问题**：如果用户对同一张拼图点了两次"同步"，会出现重复的外链。

**解决方案**：在添加外链时检查是否已存在。

```javascript
const addExternalLink = (externalLink, imageLinks) => {
  // 检查是否已存在相同的外链
  const existingIndex = externalLinks.value.findIndex(
    item => normalizeUrl(item.externalLink) === normalizeUrl(externalLink)
  )
  
  if (existingIndex >= 0) {
    ElMessage.warning('该外链已同步过，不再重复追加')
    return
  }
  
  // 检查是否是首次（覆盖模式）
  const isFirst = externalLinks.value.length === 0
  
  if (isFirst) {
    // 首次：覆盖
    externalLinks.value = [{
      externalLink,
      imageLinks: imageLinks.map(item => normalizeUrl(item.link))
    }]
  } else {
    // 后续：追加
    externalLinks.value.push({
      externalLink,
      imageLinks: imageLinks.map(item => normalizeUrl(item.link))
    })
  }
  
  // 更新映射关系
  imageLinkMapping.value[normalizeUrl(externalLink)] = imageLinks.map(item => normalizeUrl(item.link))
  
  // 更新商品图片链接字段
  updateProductImageLinksField()
  
  ElMessage.success('外链已同步')
}
```

---

### 2.6 BroadcastChannel（可选方案）⚠️ 部分采纳

**说明**：如果使用 `pinia-plugin-persistedstate` 配合 `localStorage`，实际上已经可以通过存储共享在标签页间同步状态。但如果需要实时同步（无需手动刷新），可以使用 BroadcastChannel。

**使用场景**：如果图片拼接页面和广告投放页面在不同的标签页中打开，需要实时同步。

**实现方式**：

```javascript
// 在图片拼接页面（ImageStitch.vue）
const syncExternalLinkToAdCampaign = (externalLink, imageLinks) => {
  // 方式1：使用 Pinia Store（推荐，因为已有持久化）
  const adCampaignStore = useAdCampaignStore()
  adCampaignStore.addExternalLink(externalLink, imageLinks)
  
  // 方式2：使用 BroadcastChannel（如果需要实时同步）
  const bc = new BroadcastChannel('ad-campaign-sync')
  bc.postMessage({
    type: 'SYNC_EXTERNAL_LINK',
    data: {
      externalLink,
      imageLinks
    }
  })
  bc.close() // 使用完后关闭
}

// 在广告投放页面（AdCampaign.vue）
onMounted(() => {
  const bc = new BroadcastChannel('ad-campaign-sync')
  bc.onmessage = (event) => {
    if (event.data.type === 'SYNC_EXTERNAL_LINK') {
      const { externalLink, imageLinks } = event.data.data
      const adCampaignStore = useAdCampaignStore()
      adCampaignStore.addExternalLink(externalLink, imageLinks)
    }
  }
  
  onUnmounted(() => {
    bc.close()
  })
})
```

**建议**：
- 优先使用 Pinia Store + 持久化插件，因为它更简单且已能满足需求
- BroadcastChannel 作为可选方案，如果后续需要实时同步功能再添加

---

## 三、完整技术实现方案

### 3.1 依赖安装

```bash
# Excel解析库
npm install xlsx

# Pinia持久化插件
npm install pinia-plugin-persistedstate
```

### 3.2 工具函数（utils/urlNormalize.js）

```javascript
/**
 * URL归一化函数
 * 统一处理URL格式，用于匹配时忽略差异
 */
export const normalizeUrl = (url) => {
  if (!url || typeof url !== 'string') return ''
  
  try {
    const trimmedUrl = url.trim()
    if (!trimmedUrl) return ''
    
    const u = new URL(trimmedUrl)
    return (u.origin + u.pathname).toLowerCase()
  } catch (e) {
    // 降级处理：去除参数和锚点
    return trimmedUrl
      .split('?')[0]
      .split('#')[0]
      .toLowerCase()
      .trim()
  }
}
```

### 3.3 Store数据结构（stores/adCampaign.js）

```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { normalizeUrl } from '@/utils/urlNormalize'

export const useAdCampaignStore = defineStore('adCampaign', () => {
  // 表单数据
  const formData = reactive({ /* ... */ })
  
  // 数据映射关系（持久化）
  const productDataMapping = ref({
    // 外链记录数组
    externalLinks: [],
    
    // 图片链接到商品的映射（key: 归一化后的URL, value: { productId, productSpu }）
    imageToProduct: {},
    
    // 商品ID和商品SPU数组（原始数据）
    productIds: [],
    productSpus: []
  })
  
  // 添加外链的方法（带去重检查）
  const addExternalLink = (externalLink, imageLinks) => {
    const normalizedExternalLink = normalizeUrl(externalLink)
    
    // 检查是否已存在
    const existing = productDataMapping.value.externalLinks.find(
      item => normalizeUrl(item.externalLink) === normalizedExternalLink
    )
    
    if (existing) {
      ElMessage.warning('该外链已同步过，不再重复追加')
      return
    }
    
    // 归一化图片链接
    const normalizedImageLinks = imageLinks.map(item => normalizeUrl(item.link))
    
    const linkRecord = {
      externalLink,
      imageLinks: normalizedImageLinks
    }
    
    const isFirst = productDataMapping.value.externalLinks.length === 0
    
    if (isFirst) {
      productDataMapping.value.externalLinks = [linkRecord]
    } else {
      productDataMapping.value.externalLinks.push(linkRecord)
    }
    
    // 更新商品图片链接字段
    updateProductImageLinksField()
  }
  
  // 建立图片链接到商品的映射
  const buildImageToProductMapping = (productIds, productSpus, productImages) => {
    productDataMapping.value.productIds = productIds
    productDataMapping.value.productSpus = productSpus
    
    const mapping = {}
    productImages.forEach((imageUrl, index) => {
      const normalizedUrl = normalizeUrl(imageUrl)
      if (normalizedUrl && productIds[index] && productSpus[index]) {
        mapping[normalizedUrl] = {
          productId: productIds[index],
          productSpu: productSpus[index]
        }
      }
    })
    
    productDataMapping.value.imageToProduct = mapping
  }
  
  // 更新商品图片链接字段
  const updateProductImageLinksField = () => {
    const links = productDataMapping.value.externalLinks.map(item => item.externalLink)
    formData['商品图片链接'] = links.join('\n')
  }
  
  // 检测对齐状态
  const checkAlignmentStatus = () => {
    const externalLinks = productDataMapping.value.externalLinks || []
    const imageToProduct = productDataMapping.value.imageToProduct || {}
    
    let alignedCount = 0
    let unmatchedImages = []
    let incompleteGroups = []
    
    externalLinks.forEach((linkRecord) => {
      const { imageLinks } = linkRecord
      const matchedProducts = []
      
      imageLinks.forEach(imageLink => {
        const normalizedLink = normalizeUrl(imageLink)
        const product = imageToProduct[normalizedLink]
        
        if (product) {
          matchedProducts.push({ imageLink, product })
        } else {
          unmatchedImages.push(imageLink)
        }
      })
      
      if (matchedProducts.length === 3) {
        alignedCount++
      } else if (matchedProducts.length > 0) {
        incompleteGroups.push({
          externalLink: linkRecord.externalLink,
          matched: matchedProducts.length,
          total: 3
        })
      }
    })
    
    return {
      totalGroups: externalLinks.length,
      alignedCount,
      unmatchedImagesCount: unmatchedImages.length,
      incompleteGroups,
      unmatchedImages
    }
  }
  
  return {
    formData,
    productDataMapping,
    addExternalLink,
    buildImageToProductMapping,
    updateProductImageLinksField,
    checkAlignmentStatus
  }
}, {
  persist: {
    key: 'ad-campaign-data',
    storage: window.localStorage,
    paths: ['productDataMapping'] // 只持久化映射数据
  }
})
```

---

## 四、实现步骤（优化后）

### 阶段一：基础工具和配置
1. ✅ 安装依赖（xlsx, pinia-plugin-persistedstate）
2. ✅ 配置Pinia持久化插件
3. ✅ 创建URL归一化工具函数

### 阶段二：Excel表格导入功能（增强版）
1. ✅ 添加导入按钮和文件选择
2. ✅ 实现Excel文件解析
3. ✅ 实现自动表头识别
4. ✅ 实现手动映射功能（当自动识别失败时）
5. ✅ 实现导入预览功能
6. ✅ 实现数据筛选（"商品属性*"为"M"）
7. ✅ 使用归一化URL建立映射关系
8. ✅ 实现数据提取和填充到表单

### 阶段三：图片拼接外链同步功能（增强版）
1. ✅ 修改imageStitch.js store，添加拼图记录数据结构
2. ✅ 修改ImageStitch.vue，记录每个槽位的图片链接（使用归一化URL）
3. ✅ 实现外链上传后的记录功能
4. ✅ 实现同步到广告投放页面的功能（使用Store）
5. ✅ 实现去重检查
6. ⚠️ （可选）实现BroadcastChannel实时同步

### 阶段四：数据对应关系管理（增强版）
1. ✅ 在adCampaign.js store中添加数据映射结构（持久化）
2. ✅ 实现Excel导入时的映射建立（使用归一化URL）
3. ✅ 实现外链同步时的映射建立（使用归一化URL）
4. ✅ 实现通过图片链接查找商品信息的逻辑（使用归一化URL匹配）

### 阶段五：对齐功能（增强版）
1. ✅ 添加对齐按钮
2. ✅ 实现对齐全逻辑（使用归一化URL匹配）
3. ✅ 实现对齐状态检测
4. ✅ 实现可视化反馈UI
5. ✅ 修改表格生成逻辑，支持3个一组的分组

### 阶段六：测试和优化
1. ✅ 功能测试
2. ✅ URL归一化测试（各种URL格式）
3. ✅ 持久化测试（页面刷新）
4. ✅ 边界情况处理
5. ✅ 错误处理优化
6. ✅ 用户体验优化

---

## 五、优化建议采纳情况

| 优化建议 | 采纳状态 | 说明 |
|---------|---------|------|
| 1. URL归一化 | ✅ 完全采纳 | 已实现normalizeUrl函数，在所有匹配场景使用 |
| 2. 状态持久化 | ✅ 完全采纳 | 使用pinia-plugin-persistedstate，配置简单 |
| 3. Excel智能映射与预览 | ✅ 完全采纳 | 已实现手动映射和预览功能 |
| 4. 对齐功能视觉反馈 | ✅ 完全采纳 | 已实现对齐状态检测和可视化UI |
| 5. 外链同步去重 | ✅ 完全采纳 | 已实现去重检查逻辑 |
| 6. BroadcastChannel | ⚠️ 部分采纳 | 作为可选方案，优先使用Store持久化 |

---

## 六、注意事项

1. **URL归一化的重要性**：所有涉及图片链接匹配的地方都必须使用归一化函数
2. **持久化数据管理**：注意localStorage的大小限制，大量数据时可能需要清理策略
3. **用户体验**：所有操作都要有明确的反馈（成功/失败提示）
4. **错误处理**：Excel解析、URL解析等各个环节都需要完善的错误处理
5. **性能优化**：大量数据时，归一化和匹配操作需要考虑性能
6. **数据一致性**：确保外链、图片链接、商品ID/SPU的对应关系正确

---

## 七、测试用例（优化后）

### 7.1 URL归一化测试
- ✅ 测试 http vs https
- ✅ 测试带参数 vs 不带参数
- ✅ 测试大小写差异
- ✅ 测试锚点（#）处理
- ✅ 测试异常URL格式

### 7.2 持久化测试
- ✅ 测试页面刷新后数据是否保留
- ✅ 测试跨标签页数据共享（如果使用localStorage）
- ✅ 测试数据量大的情况

### 7.3 Excel导入测试
- ✅ 测试正常Excel文件导入
- ✅ 测试自动表头识别
- ✅ 测试手动映射功能
- ✅ 测试导入预览功能
- ✅ 测试"商品属性*"筛选功能
- ✅ 测试数据缺失情况

### 7.4 对齐功能测试
- ✅ 测试正常对齐
- ✅ 测试对齐状态检测
- ✅ 测试可视化反馈显示
- ✅ 测试数据不完整情况
- ✅ 测试数量不匹配情况

### 7.5 外链同步测试
- ✅ 测试首次同步（覆盖模式）
- ✅ 测试后续同步（追加模式）
- ✅ 测试去重功能
- ✅ 测试URL归一化后的匹配

---

## 八、总结

本优化方案在原有方案基础上，采纳了以下关键优化：

1. **URL归一化**：解决了URL格式不一致导致的匹配失败问题
2. **状态持久化**：解决了页面刷新数据丢失的问题
3. **智能映射与预览**：提升了Excel导入的用户体验
4. **可视化反馈**：让用户能够清楚地了解对齐状态
5. **去重机制**：避免了重复数据的问题

这些优化让整个功能更加健壮、用户友好，并且能够处理实际使用中的各种边界情况。

