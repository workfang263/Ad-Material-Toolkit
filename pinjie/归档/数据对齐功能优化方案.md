# 数据对齐功能优化方案

**日期**：2025年12月27日  
**问题**：数据对齐功能存在用户体验问题，需要优化

---

## 一、问题分析

### 1.1 当前问题

#### 问题1：对齐会覆盖手动修改
- **现象**：用户手动删除商品ID/SPU后，点击"数据对齐"会重新填充，覆盖用户的删除操作
- **原因**：`alignData` 方法直接覆盖表单数据，不检查用户是否手动修改过
- **影响**：用户无法手动调整数据，体验差

#### 问题2：状态检测不准确
- **现象**：删除外链后，预览表仍显示"全部对齐"
- **原因**：`checkAlignmentStatus` 只检查 `productDataMapping.externalLinks`，不检查表单中的实际外链
- **影响**：状态显示不准确，误导用户

#### 问题3：缺少编辑状态标记
- **现象**：无法区分"自动对齐的数据"和"手动编辑的数据"
- **原因**：没有记录数据来源（自动对齐 vs 手动编辑）
- **影响**：无法智能处理用户修改

---

## 二、方案设计

### 方案一：智能对齐（推荐）⭐

#### 2.1 核心思路

**只对齐缺失的数据，保留用户手动修改**

- 检测表单中的实际数据
- 对比映射表，找出缺失的数据
- 只填充缺失的部分，保留用户修改
- 状态检测基于表单实际数据

#### 2.2 实现逻辑

```javascript
/**
 * 智能对齐数据（方案一）
 * 只填充缺失的数据，保留用户手动修改
 */
const alignDataSmart = () => {
  // 1. 获取表单中的实际数据
  const currentIds = formData['商品ID'].split('\n').filter(id => id.trim())
  const currentSpus = formData['商品SPU'].split('\n').filter(spu => spu.trim())
  const currentLinks = formData['商品图片链接'].split('\n').filter(link => link.trim())
  
  // 2. 获取映射表中的完整数据
  const externalLinks = productDataMapping.value.externalLinks || []
  const expectedIds = []
  const expectedSpus = []
  const expectedLinks = []
  
  externalLinks.forEach((linkRecord) => {
    const { externalLink, productInfo } = linkRecord
    
    if (productInfo && productInfo.length === 3) {
      productInfo.forEach(info => {
        expectedIds.push(info.productId)
        expectedSpus.push(info.productSpu)
      })
      expectedLinks.push(externalLink)
    }
  })
  
  // 3. 检测差异：找出缺失的数据
  const missingIds = []
  const missingSpus = []
  const missingLinks = []
  
  // 对比每个位置的数据
  for (let i = 0; i < expectedIds.length; i++) {
    if (!currentIds[i] || currentIds[i] !== expectedIds[i]) {
      missingIds.push({ index: i, value: expectedIds[i] })
    }
    if (!currentSpus[i] || currentSpus[i] !== expectedSpus[i]) {
      missingSpus.push({ index: i, value: expectedSpus[i] })
    }
  }
  
  for (let i = 0; i < expectedLinks.length; i++) {
    if (!currentLinks[i] || normalizeUrl(currentLinks[i]) !== normalizeUrl(expectedLinks[i])) {
      missingLinks.push({ index: i, value: expectedLinks[i] })
    }
  }
  
  // 4. 智能填充：只填充缺失的部分
  if (missingIds.length > 0 || missingSpus.length > 0 || missingLinks.length > 0) {
    // 构建新的数据数组
    const newIds = [...currentIds]
    const newSpus = [...currentSpus]
    const newLinks = [...currentLinks]
    
    // 填充缺失的ID
    missingIds.forEach(({ index, value }) => {
      if (index < newIds.length) {
        newIds[index] = value
      } else {
        newIds.push(value)
      }
    })
    
    // 填充缺失的SPU
    missingSpus.forEach(({ index, value }) => {
      if (index < newSpus.length) {
        newSpus[index] = value
      } else {
        newSpus.push(value)
      }
    })
    
    // 填充缺失的外链
    missingLinks.forEach(({ index, value }) => {
      if (index < newLinks.length) {
        newLinks[index] = value
      } else {
        newLinks.push(value)
      }
    })
    
    // 更新表单（只更新有变化的部分）
    formData['商品ID'] = newIds.join('\n')
    formData['商品SPU'] = newSpus.join('\n')
    formData['商品图片链接'] = newLinks.join('\n')
    
    ElMessage.success(`已智能对齐：补充了 ${missingIds.length} 个商品ID，${missingSpus.length} 个商品SPU，${missingLinks.length} 个外链`)
  } else {
    ElMessage.info('数据已对齐，无需更新')
  }
}
```

#### 2.3 状态检测优化

```javascript
/**
 * 检查对齐状态（基于表单实际数据）
 * 对比表单数据和映射表，返回准确的对齐状态
 */
const checkAlignmentStatus = () => {
  if (workflowMode.value !== 'stitch_sync') return null
  
  // 1. 获取表单中的实际数据
  const formIds = formData['商品ID'].split('\n').filter(id => id.trim())
  const formSpus = formData['商品SPU'].split('\n').filter(spu => spu.trim())
  const formLinks = formData['商品图片链接'].split('\n').filter(link => link.trim())
  
  // 2. 获取映射表中的数据
  const externalLinks = productDataMapping.value.externalLinks || []
  
  // 3. 构建对齐状态
  const groups = externalLinks.map((linkRecord, groupIndex) => {
    const { externalLink, productInfo } = linkRecord
    
    // 计算这组数据在表单中的位置
    const startIndex = groupIndex * 3
    
    // 获取这组对应的表单数据
    const groupIds = formIds.slice(startIndex, startIndex + 3)
    const groupSpus = formSpus.slice(startIndex, startIndex + 3)
    const formLink = formLinks[groupIndex]
    
    // 检查外链是否匹配
    const linkMatched = formLink && normalizeUrl(formLink) === normalizeUrl(externalLink)
    
    // 检查商品信息是否匹配
    const products = []
    if (productInfo && productInfo.length === 3) {
      productInfo.forEach((info, index) => {
        const formId = groupIds[index]
        const formSpu = groupSpus[index]
        const matched = formId === info.productId && formSpu === info.productSpu
        products.push({
          matched,
          id: formId || info.productId,
          spu: formSpu || info.productSpu,
          expectedId: info.productId,
          expectedSpu: info.productSpu
        })
      })
    }
    
    const matchedCount = products.filter(p => p.matched).length
    const complete = matchedCount === 3 && linkMatched
    
    return {
      externalLink,
      formLink,  // 表单中的实际外链
      linkMatched,  // 外链是否匹配
      products,
      matched: matchedCount,
      complete
    }
  })
  
  // 4. 检查是否有表单中的外链不在映射表中（用户手动添加的）
  const formLinksNotInMapping = formLinks.filter(formLink => {
    return !externalLinks.some(linkRecord => 
      normalizeUrl(linkRecord.externalLink) === normalizeUrl(formLink)
    )
  })
  
  // 5. 统计信息
  const alignedCount = groups.filter(g => g.complete).length
  const incompleteCount = groups.filter(g => !g.complete && g.matched > 0).length
  const unmatchedCount = groups.reduce((sum, g) => {
    return sum + g.products.filter(p => !p.matched).length
  }, 0)
  
  return {
    totalGroups: groups.length,
    alignedCount,
    incompleteCount,
    unmatchedCount,
    allAligned: alignedCount === groups.length && groups.length > 0 && formLinksNotInMapping.length === 0,
    groups,
    formLinksNotInMapping  // 表单中有但映射表中没有的外链
  }
}
```

#### 2.4 优点

✅ **尊重用户修改**：只填充缺失的数据，保留用户手动修改  
✅ **自动补全**：自动检测并填充缺失的数据  
✅ **状态准确**：基于表单实际数据检测状态  
✅ **用户体验好**：无需确认，直接智能对齐

#### 2.5 缺点

❌ **实现复杂**：需要对比表单和映射表  
❌ **需要处理边界情况**：数据不一致、顺序错乱等

---

### 方案二：确认式对齐

#### 2.1 核心思路

**对齐前弹出确认对话框，显示将要覆盖的内容**

- 点击对齐时，先对比当前表单和映射表
- 如果有差异，弹出确认对话框
- 用户选择：覆盖 / 保留手动修改 / 取消
- 根据选择执行对齐

#### 2.2 实现逻辑

```javascript
/**
 * 确认式对齐（方案二）
 * 对齐前弹出确认对话框，让用户选择
 */
const alignDataWithConfirm = async () => {
  if (workflowMode.value !== 'stitch_sync') {
    ElMessage.warning('请先切换到拼图对齐模式')
    return
  }
  
  // 1. 检测是否有手动修改
  const currentIds = formData['商品ID'].split('\n').filter(id => id.trim())
  const currentSpus = formData['商品SPU'].split('\n').filter(spu => spu.trim())
  const currentLinks = formData['商品图片链接'].split('\n').filter(link => link.trim())
  
  const externalLinks = productDataMapping.value.externalLinks || []
  const expectedIds = []
  const expectedSpus = []
  const expectedLinks = []
  
  externalLinks.forEach((linkRecord) => {
    const { externalLink, productInfo } = linkRecord
    if (productInfo && productInfo.length === 3) {
      productInfo.forEach(info => {
        expectedIds.push(info.productId)
        expectedSpus.push(info.productSpu)
      })
      expectedLinks.push(externalLink)
    }
  })
  
  // 2. 检测差异
  const differences = []
  const maxLength = Math.max(currentIds.length, expectedIds.length)
  
  for (let i = 0; i < maxLength; i++) {
    const currentId = currentIds[i] || ''
    const expectedId = expectedIds[i] || ''
    const currentSpu = currentSpus[i] || ''
    const expectedSpu = expectedSpus[i] || ''
    
    if (currentId !== expectedId || currentSpu !== expectedSpu) {
      differences.push({
        index: i + 1,
        currentId,
        expectedId,
        currentSpu,
        expectedSpu
      })
    }
  }
  
  // 3. 如果有差异，弹出确认对话框
  if (differences.length > 0) {
    const result = await ElMessageBox.confirm(
      `检测到 ${differences.length} 处数据差异，对齐操作将覆盖这些数据。\n\n` +
      `是否继续？`,
      '确认对齐',
      {
        confirmButtonText: '覆盖并对齐',
        cancelButtonText: '取消',
        type: 'warning',
        distinguishCancelAndClose: true,
        showClose: false
      }
    ).catch(() => 'cancel')
    
    if (result === 'cancel') {
      return
    }
  }
  
  // 4. 执行对齐（原有逻辑）
  const alignedProductIds = []
  const alignedProductSpus = []
  
  externalLinks.forEach((linkRecord) => {
    const { productInfo } = linkRecord
    if (productInfo && productInfo.length === 3) {
      productInfo.forEach(info => {
        alignedProductIds.push(info.productId)
        alignedProductSpus.push(info.productSpu)
      })
    }
  })
  
  formData['商品ID'] = alignedProductIds.join('\n')
  formData['商品SPU'] = alignedProductSpus.join('\n')
  
  ElMessage.success('数据对齐完成')
}
```

#### 2.3 优点

✅ **用户可控**：用户可以选择是否覆盖  
✅ **避免意外**：确认对话框防止误操作  
✅ **变更清晰**：显示将要覆盖的内容

#### 2.4 缺点

❌ **需要确认**：每次对齐都需要确认，可能打断工作流  
❌ **体验稍差**：多一步操作

---

### 方案三：差异检测与提示

#### 2.1 核心思路

**检测表单与映射表的差异，在预览表中高亮显示**

- 实时检测表单和映射表的差异
- 在预览表中标记差异项
- 提供"同步差异"按钮，按需对齐

#### 2.2 实现逻辑

```javascript
/**
 * 检测数据差异（方案三）
 * 返回表单和映射表之间的差异
 */
const detectDifferences = () => {
  const currentIds = formData['商品ID'].split('\n').filter(id => id.trim())
  const currentSpus = formData['商品SPU'].split('\n').filter(spu => spu.trim())
  const currentLinks = formData['商品图片链接'].split('\n').filter(link => link.trim())
  
  const externalLinks = productDataMapping.value.externalLinks || []
  const differences = []
  
  externalLinks.forEach((linkRecord, groupIndex) => {
    const { externalLink, productInfo } = linkRecord
    const startIndex = groupIndex * 3
    
    if (productInfo && productInfo.length === 3) {
      productInfo.forEach((info, index) => {
        const formIndex = startIndex + index
        const formId = currentIds[formIndex]
        const formSpu = currentSpus[formIndex]
        
        if (formId !== info.productId || formSpu !== info.productSpu) {
          differences.push({
            groupIndex,
            productIndex: index,
            formIndex,
            expected: { id: info.productId, spu: info.productSpu },
            actual: { id: formId, spu: formSpu }
          })
        }
      })
    }
    
    // 检查外链
    const formLink = currentLinks[groupIndex]
    if (formLink && normalizeUrl(formLink) !== normalizeUrl(externalLink)) {
      differences.push({
        groupIndex,
        type: 'link',
        expected: externalLink,
        actual: formLink
      })
    }
  })
  
  return differences
}

/**
 * 同步差异（方案三）
 * 只同步有差异的数据
 */
const syncDifferences = () => {
  const differences = detectDifferences()
  
  if (differences.length === 0) {
    ElMessage.info('没有检测到差异')
    return
  }
  
  // 只更新有差异的部分
  const currentIds = formData['商品ID'].split('\n').filter(id => id.trim())
  const currentSpus = formData['商品SPU'].split('\n').filter(spu => spu.trim())
  const currentLinks = formData['商品图片链接'].split('\n').filter(link => link.trim())
  
  differences.forEach(diff => {
    if (diff.type === 'link') {
      currentLinks[diff.groupIndex] = diff.expected
    } else {
      currentIds[diff.formIndex] = diff.expected.id
      currentSpus[diff.formIndex] = diff.expected.spu
    }
  })
  
  formData['商品ID'] = currentIds.join('\n')
  formData['商品SPU'] = currentSpus.join('\n')
  formData['商品图片链接'] = currentLinks.join('\n')
  
  ElMessage.success(`已同步 ${differences.length} 处差异`)
}
```

#### 2.3 预览表增强

在预览表中显示差异标记：

```vue
<div class="preview-item" :class="{
  'item-complete': group.complete,
  'item-different': group.hasDifference  // 新增：有差异的标记
}">
  <!-- 差异提示 -->
  <el-tag v-if="group.hasDifference" type="warning" size="small">
    数据已修改
  </el-tag>
</div>
```

#### 2.4 优点

✅ **可视化差异**：在预览表中标记差异  
✅ **按需同步**：用户可以选择是否同步  
✅ **不强制覆盖**：尊重用户修改

#### 2.5 缺点

❌ **需要手动同步**：用户需要主动点击同步按钮  
❌ **可能遗漏**：用户可能忘记同步差异

---

## 三、方案对比

| 特性 | 方案一：智能对齐 | 方案二：确认式对齐 | 方案三：差异检测 |
|------|----------------|------------------|----------------|
| **用户体验** | ⭐⭐⭐⭐⭐ 最好 | ⭐⭐⭐ 一般 | ⭐⭐⭐⭐ 较好 |
| **实现复杂度** | ⭐⭐⭐ 中等 | ⭐⭐ 简单 | ⭐⭐⭐⭐ 较复杂 |
| **用户控制** | ⭐⭐⭐⭐ 较好 | ⭐⭐⭐⭐⭐ 最好 | ⭐⭐⭐⭐ 较好 |
| **自动化程度** | ⭐⭐⭐⭐⭐ 最高 | ⭐⭐ 较低 | ⭐⭐⭐ 中等 |
| **状态准确性** | ⭐⭐⭐⭐⭐ 最高 | ⭐⭐⭐⭐ 较高 | ⭐⭐⭐⭐⭐ 最高 |

---

## 四、推荐方案

### 推荐：方案一（智能对齐）+ 方案三（差异检测）组合

**组合方案的优势：**

1. **智能对齐**：默认行为，自动补全缺失数据
2. **差异检测**：在预览表中标记差异，让用户知道哪些数据被修改了
3. **状态准确**：基于表单实际数据检测状态
4. **用户友好**：既自动化，又可视化

**实现步骤：**

1. 实现智能对齐逻辑（方案一）
2. 优化状态检测（基于表单实际数据）
3. 在预览表中标记差异（方案三）
4. 添加"重置对齐"功能（可选）

---

## 五、实施建议

### 5.1 优先级

1. **高优先级**：优化状态检测（基于表单实际数据）
2. **中优先级**：实现智能对齐逻辑
3. **低优先级**：差异标记和重置功能

### 5.2 测试场景

1. 删除商品ID后对齐
2. 删除商品SPU后对齐
3. 删除外链后对齐
4. 修改商品ID后对齐
5. 混合场景（部分删除、部分修改）

---

## 六、总结

数据对齐功能需要优化，推荐使用**智能对齐 + 差异检测**的组合方案，既能自动补全缺失数据，又能可视化显示差异，提供最佳的用户体验。

